{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-deferred-type-errors #-}

-- |
module WGPU.CodeGen.Pretty where

import Chronos (Datetime, encodeIso8601, now, timeToDatetime)
import Data.Foldable (find, for_)
import Data.Functor ((<&>))
import Data.List (intersperse)
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import qualified Data.Text as Text
import qualified Data.Text.IO as Text
import Prettyprinter
  ( Doc,
    LayoutOptions (LayoutOptions, layoutPageWidth),
    PageWidth (AvailablePerLine),
    hang,
    hardline,
    indent,
    layoutPretty,
    pretty,
    (<+>),
  )
import Prettyprinter.Render.Text (renderStrict)
import System.Directory (createDirectoryIfMissing)
import System.FilePath (takeDirectory)
import Text.Printf (printf)
import WGPU.CodeGen.Haskell
  ( HaskellApi (haskellApiEnums, haskellApiFuns, haskellApiStructs),
    HsEnumW32 (HsEnumW32, hsEnumW32Name),
    HsEnumW32Member (HsEnumW32Member),
    HsFun (HsFun),
    HsFunParam (HsFunParam),
    HsStruct (HsStruct, hsStructMembers),
    HsStructMember (HsStructMember),
    hsStructName,
  )
import WGPU.CodeGen.Parse (CType (CBool, CChar, CDefined, CDouble, CFloat, CInt, CPtr, CVoid))
import WGPU.Metadata.Git (getWGPUSubmoduleString)

-------------------------------------------------------------------------------

export :: FilePath -> Module -> HaskellApi -> IO ()
export rawProjectDir modl api = do
  metadata <- fetchMetadata

  let srcDir = rawProjectDir <> "/src"

  -- write enums (one file per enum)
  let enumsModl = modl <> Module ["Enum"]
  for_ (haskellApiEnums api) $ \enum -> do
    let curModl = enumsModl <> Module [hsEnumW32Name enum]
        fileName = srcDir <> "/" <> moduleToPath curModl <> ".hs"
        genTxt = pprHsEnumW32 metadata enumsModl enum
    putStrLn "Writing enum:"
    putStrLn $ "  Module: " <> Text.unpack (moduleToDotModule curModl)
    putStrLn $ "  File:   " <> fileName
    createAndWriteFile fileName genTxt

  -- write structs (one file per struct)
  let structsModl = modl <> Module ["Struct"]
  for_ (haskellApiStructs api) $ \struct -> do
    let curModl = structsModl <> Module [hsStructName struct]
        fileName = srcDir <> "/" <> moduleToPath curModl <> ".hsc"
        genTxt = pprHsStruct api metadata modl structsModl struct
    putStrLn "Writing struct:"
    putStrLn $ "  Module: " <> Text.unpack (moduleToDotModule curModl)
    putStrLn $ "  File:   " <> fileName
    createAndWriteFile fileName genTxt

  -- write functions (single file)
  do
    let funModl = modl <> Module ["Fun"]
        fileName = srcDir <> "/" <> moduleToPath funModl <> ".hs"
        genTxt = pprHsFuns api metadata modl funModl
    putStrLn "Writing functions:"
    putStrLn $ "  Module: " <> Text.unpack (moduleToDotModule funModl)
    putStrLn $ "  File:   " <> fileName
    createAndWriteFile fileName genTxt

createAndWriteFile :: FilePath -> Text -> IO ()
createAndWriteFile path content = do
  createDirectoryIfMissing True $ takeDirectory path
  Text.writeFile path content

-------------------------------------------------------------------------------

fetchMetadata :: IO Metadata
fetchMetadata = Metadata <$> getWGPUSubmoduleString <*> (timeToDatetime <$> now)

data Metadata = Metadata
  { metadataGit :: !Text,
    metadataDateTime :: !Datetime
  }

-------------------------------------------------------------------------------

newtype Module = Module [Text] deriving (Eq, Show)

instance Semigroup Module where
  (Module as) <> (Module bs) = Module (as <> bs)

moduleToPath :: Module -> FilePath
moduleToPath (Module xs) = Text.unpack $ Text.intercalate "/" xs

moduleToDotModule :: Module -> Text
moduleToDotModule (Module xs) = Text.intercalate "." xs

docModuleHeader :: Module -> Doc ann
docModuleHeader m = "module" <+> pretty (moduleToDotModule m) <+> "where"

-------------------------------------------------------------------------------

docGeneratedHeader :: Metadata -> Doc ann
docGeneratedHeader md =
  "-- This file was generated by wgpu-raw-hs-codegen on:"
    <> hardline
    <> "--   "
    <> pretty (encodeIso8601 . metadataDateTime $ md)
    <> hardline
    <> "-- Using wgpu-native git hash:"
    <> hardline
    <> "--   "
    <> pretty (metadataGit md)

-------------------------------------------------------------------------------

pprHsEnumW32 :: Metadata -> Module -> HsEnumW32 -> Text
pprHsEnumW32 metaData modPrefix (HsEnumW32 name members) =
  renderStrict $ layoutPretty layoutOptions doc
  where
    layoutOptions = LayoutOptions {layoutPageWidth = AvailablePerLine 80 1}
    doc =
      mconcat $
        intersperse gap $
          [ docHsEnumW32Extensions,
            docGeneratedHeader metaData,
            docModuleHeader (modPrefix <> Module [name]),
            "import Data.Word (Word32)" <> hardline
              <> "import Foreign (Storable)"
              <> hardline
              <> "import Prelude (Eq, Show, Num)",
            docHsEnumW32Newtype name
          ]
            <> (docHsEnumW32MemberPattern <$> members)

docHsEnumW32Extensions :: Doc ann
docHsEnumW32Extensions =
  mconcat $
    intersperse hardline $
      [ "{-# LANGUAGE GeneralizedNewtypeDeriving #-}",
        "{-# LANGUAGE PatternSynonyms #-}",
        "{-# LANGUAGE ScopedTypeVariables #-}",
        "{-# LANGUAGE NoImplicitPrelude #-}"
      ]

docHsEnumW32Newtype :: Text -> Doc ann
docHsEnumW32Newtype name =
  hang 2 $
    "newtype" <+> pretty name <+> "=" <+> pretty name <+> "Word32"
      <> hardline
      <> "deriving (Eq, Show, Num, Storable)"

docHsEnumW32MemberPattern :: HsEnumW32Member -> Doc ann
docHsEnumW32MemberPattern (HsEnumW32Member name value) =
  "pattern" <+> pretty trimmedName <+> ":: forall a. (Eq a, Num a) => a"
    <> hardline
    <> "pattern" <+> pretty trimmedName <+> "=" <+> pretty hexValue
  where
    hexValue :: String
    hexValue = printf "0x%08X" value

    trimmedName :: Text
    trimmedName =
      renameMember $
        let tl = Text.tail (Text.dropWhile (/= '_') name)
         in if Text.null tl
              then
                error $
                  "Enum member " <> Text.unpack name <> " could not be "
                    <> "re-written using underscore rule"
              else tl

-- | Rename invalid enum and struct members.
--
-- After name stripping, some enum members have invalid names. Here, we re-name
-- them using a custom list of replacements.
renameMember :: Text -> Text
renameMember txt = fromMaybe txt $ Map.lookup txt replacements
  where
    replacements :: Map Text Text
    replacements =
      Map.fromList
        [ ("1D", "D1D"),
          ("2D", "D2D"),
          ("3D", "D3D"),
          ("2DArray", "D2DArray"),
          ("type", "typ"),
          ("module", "shaderModule")
        ]

-------------------------------------------------------------------------------

pprHsStruct :: HaskellApi -> Metadata -> Module -> Module -> HsStruct -> Text
pprHsStruct api metaData base modPrefix struct =
  renderStrict $ layoutPretty layoutOptions doc
  where
    layoutOptions = LayoutOptions {layoutPageWidth = AvailablePerLine 80 1}
    doc = docHsStructFile api metaData base modPrefix struct

docHsStructFile :: HaskellApi -> Metadata -> Module -> Module -> HsStruct -> Doc ann
docHsStructFile api metadata base modPrefix struct =
  mconcat $
    intersperse gap $
      [ docExtensions,
        docGeneratedHeader metadata,
        docModuleHeader (modPrefix <> Module [name]),
        ( mconcat $
            intersperse
              hardline
              [ "#include \"wgpu.h\"",
                "",
                "import Data.Word (Word16, Word32, Word64)",
                "import Data.Int (Int32)",
                "import Foreign",
                "import Foreign.C.Types",
                "import WGPU.Raw.Types",
                "import Prelude (pure, ($!))"
              ]
        )
          <> hardline
          <> docImports,
        docDataDecl,
        docStorable
      ]
  where
    name :: Text
    name = hsStructName struct

    members :: [HsStructMember]
    members = hsStructMembers struct

    docExtensions :: Doc ann
    docExtensions =
      mconcat $
        intersperse hardline $
          [ "{-# OPTIONS_GHC -Wno-unused-imports #-}",
            "{-# LANGUAGE RecordWildCards #-}",
            "{-# LANGUAGE NoImplicitPrelude #-}"
          ]

    docDataDecl :: Doc ann
    docDataDecl =
      "data" <+> pretty name <+> "=" <+> pretty name <+> "{" <> hardline
        <> mconcat (intersperse ("," <> hardline) docMembers)
        <> hardline
        <> "}"

    docStorable :: Doc ann
    docStorable =
      hang 2 $
        "instance Storable" <+> pretty name <+> "where" <> hardline
          <> "sizeOf _ =" <+> "(#size" <+> pretty name
          <> ")"
          <> hardline
          <> "alignment = sizeOf"
          <> hardline
          <> "peek ptr = do"
          <> hardline
          <> ( indent 2 $
                 mconcat $
                   intersperse hardline $
                     ( members <&> \(HsStructMember mName' _) ->
                         let mName = renameMember mName'
                          in pretty mName <+> "<-"
                               <+> "(#peek"
                               <+> pretty name <> ","
                               <+> pretty mName' <> ") ptr"
                     )
                       <> [ "pure $!" <+> pretty name <> "{..}"
                          ]
             )
          <> hardline
          <> "poke ptr" <+> pretty name
          <> "{..}" <+> "= do"
          <> hardline
          <> ( indent 2 $
                 mconcat $
                   intersperse hardline $
                     ( members <&> \(HsStructMember mName' _) ->
                         let mName = renameMember mName'
                          in "(#poke"
                               <+> pretty name <> ","
                               <+> pretty mName' <> ") ptr"
                               <+> pretty mName
                     )
             )

    memberInfo :: [(Doc ann, TypeInfo ann)]
    memberInfo = getMemberInfo <$> members

    docMembers :: [Doc ann]
    docMembers = fst <$> memberInfo

    docImports :: Doc ann
    docImports =
      mconcat $
        intersperse hardline (docEnumImports <> docStructImports)

    docEnumImports :: [Doc ann]
    docEnumImports =
      docEnumImport
        <$> filter
          (\(HsEnumW32 n _) -> n /= name)
          (mconcat (typeInfoEnums . snd <$> memberInfo))

    docEnumImport :: HsEnumW32 -> Doc ann
    docEnumImport (HsEnumW32 n _) =
      "import" <+> pretty (moduleToDotModule (base <> Module ["Enum", n]))

    docStructImports :: [Doc ann]
    docStructImports =
      docStructImport
        <$> filter
          (\(HsStruct n _) -> n /= name)
          (mconcat (typeInfoStructs . snd <$> memberInfo))

    docStructImport :: HsStruct -> Doc ann
    docStructImport (HsStruct n _) =
      "import" <+> pretty (moduleToDotModule (base <> Module ["Struct", n]))

    getMemberInfo :: HsStructMember -> (Doc ann, TypeInfo ann)
    getMemberInfo (HsStructMember mname typ) =
      let typeInfo = getTypeInfo api typ
          mname' = renameMember mname
       in (indent 2 $ pretty mname' <+> "::" <+> typeInfoDoc typeInfo, typeInfo)

-------------------------------------------------------------------------------

pprHsFuns :: HaskellApi -> Metadata -> Module -> Module -> Text
pprHsFuns api metadata base modPrefix =
  renderStrict $ layoutPretty layoutOptions doc
  where
    layoutOptions = LayoutOptions {layoutPageWidth = AvailablePerLine 80 1}
    doc = docHsFuns api metadata base modPrefix

docHsFuns :: HaskellApi -> Metadata -> Module -> Module -> Doc ann
docHsFuns api metadata base modPrefix =
  mconcat $
    intersperse gap $
      [ docExtensions,
        docGeneratedHeader metadata,
        docModuleHeader modPrefix,
        ( mconcat $
            intersperse
              hardline
              [ "import Foreign",
                "import Foreign.C",
                "import Prelude (IO)",
                "import WGPU.Raw.Types"
              ]
        )
          <> hardline
          <> docImports,
        docFuns
      ]
  where
    docExtensions :: Doc ann
    docExtensions =
      mconcat $
        intersperse hardline $
          [ "{-# OPTIONS_GHC -Wno-unused-imports #-}",
            "{-# LANGUAGE ForeignFunctionInterface #-}",
            "{-# LANGUAGE NoImplicitPrelude #-}"
          ]

    docImports :: Doc ann
    docImports =
      mconcat $
        intersperse hardline $
          ( haskellApiEnums api <&> \(HsEnumW32 n _) ->
              let m = moduleToDotModule $ base <> Module ["Enum", n]
               in "import" <+> pretty m
          )
            <> ( haskellApiStructs api <&> \(HsStruct n _) ->
                   let m = moduleToDotModule $ base <> Module ["Struct", n]
                    in "import" <+> pretty m
               )

    typDoc :: CType -> Doc ann
    typDoc = typeInfoDoc . getTypeInfo api

    docFuns :: Doc ann
    docFuns =
      mconcat $
        intersperse gap $
          haskellApiFuns api <&> \(HsFun n ps t) ->
            hang 2 $
              "foreign import ccall \"" <> pretty n <> "\"" <> hardline
                <> pretty n <+> "::" <+> docFnParams ps
                <> (if not (null ps) then " -> " else " ")
                <> "IO ("
                <> typDoc t
                <> ")"

    docFnParams :: [HsFunParam] -> Doc ann
    docFnParams ps =
      mconcat $
        intersperse " -> " $
          ps <&> \(HsFunParam _ t) -> typDoc t

-------------------------------------------------------------------------------

data TypeInfo ann = TypeInfo
  { typeInfoDoc :: Doc ann,
    typeInfoEnums :: [HsEnumW32],
    typeInfoStructs :: [HsStruct]
  }

getTypeInfo :: HaskellApi -> CType -> TypeInfo ann
getTypeInfo api ctyp =
  case ctyp of
    CPtr ctyp' ->
      let ti = getTypeInfo api ctyp'
       in ti {typeInfoDoc = "Ptr (" <> typeInfoDoc ti <> ")"}
    CVoid -> TypeInfo "()" [] []
    CBool -> TypeInfo "CBool" [] []
    CChar -> TypeInfo "CChar" [] []
    CInt -> TypeInfo "CInt" [] []
    CFloat -> TypeInfo "CFloat" [] []
    CDouble -> TypeInfo "CDouble" [] []
    CDefined "int32_t" -> TypeInfo "Int32" [] []
    CDefined "uint16_t" -> TypeInfo "Word16" [] []
    CDefined "uint32_t" -> TypeInfo "Word32" [] []
    CDefined "uint64_t" -> TypeInfo "Word64" [] []
    CDefined "size_t" -> TypeInfo "CSize" [] []
    CDefined txt ->
      case lookupType api txt of
        (es, ss) -> TypeInfo (pretty txt) es ss

lookupType :: HaskellApi -> Text -> ([HsEnumW32], [HsStruct])
lookupType api typ =
  let mEnum :: Maybe HsEnumW32
      mEnum = find (\(HsEnumW32 n _) -> n == typ) (haskellApiEnums api)

      mStruct :: Maybe HsStruct
      mStruct = find (\(HsStruct n _) -> n == typ) (haskellApiStructs api)
   in case (mEnum, mStruct) of
        (Just e, Nothing) -> ([e], [])
        (Nothing, Just s) -> ([], [s])
        (Just _, Just _) ->
          error $ "Found " <> Text.unpack typ <> " as both a struct and enum"
        (Nothing, Nothing) -> ([], [])

-------------------------------------------------------------------------------

gap :: Doc ann
gap = hardline <> hardline
